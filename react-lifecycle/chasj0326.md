# Function Component 의 생명주기

- 마운트 : 컴포넌트가 화면에 추가
- 업데이트 : 새로운 props 나 state 를 받았을 때 업데이트
- 언마운트 : 컴포넌트가 화면에서 제거

<br>

## 마운트와 렌더링의 차이

`마운트` : 처음으로 컴포넌트를 렌더링하여 화면에 추가하는 시기

`렌더링` : 컴포넌트가 호출되는 것

생명주기 관점으로는 **마운트→업데이트→언마운트** 가 맞음!
렌더링은 그냥 **호출**되는 것을 렌더링이라고 칭하는 것
마운트 때 렌더링, 업데이트 때 리렌더링

<br>

## useEffect 와 라이프사이클

### Effect 란?

- 특정 사용자 작업(클릭, 입력, …)과 관계 없이 발생해야 하는 작업
- 렌더링 이후의 사이드 이펙트
  - 화면 업데이트 후 커밋(DOM에 올리기)이 끝날 때 실행
  - 외부 시스템(브라우저 API, 네트워크 등)과 동기화하는 등의 작업
- Effect를 다루기 위한 훅이 `useEffect`

<br>

### **Effect 의 자체 주기(?)**

> 이전에는 컴포넌트의 관점에서 생각했습니다. 컴포넌트의 관점에서 보면 Effect를 `렌더링 후` 또는 `마운트 해제 전`과 같은 특정 시점에 실행되는 `콜백` 또는 `생명주기 이벤트`로 생각하기 쉬웠습니다. 이러한 사고 방식은 매우 빠르게 복잡해지므로 피하는 것이 가장 좋습니다. 😭🥲
>
> _from. 공식문서_

```tsx
const User = ({ id }) => {
  useEffect(() => {
    console.log(id, '동기화 시작');
    return () => {
      console.log(id, '동기화 중지');
    };
  }, [id]);

  // 생략
};
```

**컴포넌트의 주기 : 마운트 ⇒ 업데이트 ⇒ 언마운트**

1. id 가 `seeyoujeong` 인 상태로 User가 마운트
2. id 가 `suyeon1218` 인 상태로 User가 업데이트
3. id 가 `chasj0326` 인 상태로 User가 업데이트
4. User가 언마운트

**이펙트의 주기 : 동기화 ⇒ 동기화 중지**

1. Effect가 `seeyoujeong` User와 연결
2. Effect가 `seeyoujeong` 과 연결이 끊어지고 `suyeon1218` User와 연결
3. Effect가 `suyeon1218` 과 연결이 끊어지고 `chasj0326` User와 연결
4. Effect가 `chasj0326` 과 연결이 끊어짐

따라서, 콘솔에는 아래와 같이 출력된다.

```tsx
seeyoujeong 동기화 시작
seeyoujeong 동기화 중지
suyeon1218 동기화 시작
suyeon1218 동기화 중지
chasj0326 동기화 시작
chasj0326 동기화 중지
```

<br>

### useEffect 와 라이프사이클

> 대신 항상 한 번에 하나의 시작/중지 사이클에만 집중하세요. 컴포넌트를 마운트, 업데이트 또는 마운트 해제하는 것은 중요하지 않습니다. 동기화를 시작하는 방법과 중지하는 방법만 설명하면 됩니다. 이 작업을 잘 수행하면 필요한 횟수만큼 Effect를 시작하고 중지할 수 있는 탄력성을 확보할 수 있습니다.
>
> _from. 공식문서_

**useEffect 를 사용해 컴포넌트 라이프사이클에 접근한다** 라고 말할 수 있다. (아래 예시)

```tsx
useEffect(() => {
  // 컴포넌트 마운트

  return () => {
    // 컴포넌트 언마운트
  };
}, []);
```

또는

```tsx
useEffect(() => {
  // 컴포넌트 마운트
  // 또는 id값으로 인한 컴포넌트 업데이트

  return () => {
    // 컴포넌트 언마운트
    // 또는 id값으로 인한 컴포넌트 업데이트
    // (새로운 값으로 갱신되면 이전값 클린업 실행)
  };
}, [id]);
```

하지만, 이건 결과적으로 그렇게 된 것 뿐..
공식문서에서는 **컴포넌트와 Effect 의 주기를 별개로 생각**하라고 말하고 있다!

useEffect 는 dependency 내부의 반응형 값과 `동기화 ⇒ 동기화 중지` 를 실행하는 친구일 뿐이다. dependency 로 아무것도 주어지지 않는다면, 당연하게도 ... 컴포넌트가 렌더링 된 후 동기화를 시작하고 언마운트될 때 동기화를 중지하는 것이다.
